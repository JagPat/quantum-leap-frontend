import { AppDispatch } from '../store/store';\nimport {\n  checkConnectionStatus,\n  refreshTokens,\n  BrokerConfig,\n  ConnectionStatus\n} from '../store/broker/brokerSlice';\n\nexport interface ConnectionManagerOptions {\n  maxRetries?: number;\n  baseRetryDelay?: number;\n  maxRetryDelay?: number;\n  healthCheckInterval?: number;\n  tokenRefreshThreshold?: number; // Minutes before expiry to refresh\n}\n\nconst DEFAULT_OPTIONS: Required<ConnectionManagerOptions> = {\n  maxRetries: 5,\n  baseRetryDelay: 5000, // 5 seconds\n  maxRetryDelay: 300000, // 5 minutes\n  healthCheckInterval: 60000, // 1 minute\n  tokenRefreshThreshold: 30 // 30 minutes before expiry\n};\n\nexport class ConnectionManager {\n  private dispatch: AppDispatch;\n  private options: Required<ConnectionManagerOptions>;\n  private intervals: Map<string, NodeJS.Timeout> = new Map();\n  private retryTimeouts: Map<string, NodeJS.Timeout> = new Map();\n  private retryCounts: Map<string, number> = new Map();\n  private listeners: Map<string, Set<(status: ConnectionStatus) => void>> = new Map();\n\n  constructor(dispatch: AppDispatch, options: ConnectionManagerOptions = {}) {\n    this.dispatch = dispatch;\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  /**\n   * Start monitoring a broker configuration\n   */\n  startMonitoring(config: BrokerConfig): void {\n    console.log(`üîÑ Starting connection monitoring for config ${config.id}`);\n    \n    // Clear any existing monitoring\n    this.stopMonitoring(config.id);\n    \n    // Start health check interval\n    const interval = setInterval(() => {\n      this.performHealthCheck(config.id);\n    }, this.options.healthCheckInterval);\n    \n    this.intervals.set(config.id, interval);\n    \n    // Perform initial health check\n    this.performHealthCheck(config.id);\n  }\n\n  /**\n   * Stop monitoring a broker configuration\n   */\n  stopMonitoring(configId: string): void {\n    console.log(`‚èπÔ∏è Stopping connection monitoring for config ${configId}`);\n    \n    // Clear health check interval\n    const interval = this.intervals.get(configId);\n    if (interval) {\n      clearInterval(interval);\n      this.intervals.delete(configId);\n    }\n    \n    // Clear retry timeout\n    const retryTimeout = this.retryTimeouts.get(configId);\n    if (retryTimeout) {\n      clearTimeout(retryTimeout);\n      this.retryTimeouts.delete(configId);\n    }\n    \n    // Reset retry count\n    this.retryCounts.delete(configId);\n  }\n\n  /**\n   * Add a status change listener\n   */\n  addStatusListener(configId: string, listener: (status: ConnectionStatus) => void): void {\n    if (!this.listeners.has(configId)) {\n      this.listeners.set(configId, new Set());\n    }\n    this.listeners.get(configId)!.add(listener);\n  }\n\n  /**\n   * Remove a status change listener\n   */\n  removeStatusListener(configId: string, listener: (status: ConnectionStatus) => void): void {\n    const configListeners = this.listeners.get(configId);\n    if (configListeners) {\n      configListeners.delete(listener);\n      if (configListeners.size === 0) {\n        this.listeners.delete(configId);\n      }\n    }\n  }\n\n  /**\n   * Perform a health check for a specific configuration\n   */\n  private async performHealthCheck(configId: string): Promise<void> {\n    try {\n      console.log(`üè• Performing health check for config ${configId}`);\n      \n      const result = await this.dispatch(checkConnectionStatus({ configId })).unwrap();\n      \n      // Reset retry count on successful health check\n      this.retryCounts.set(configId, 0);\n      \n      // Check if token needs refresh\n      if (result.tokenStatus) {\n        await this.checkTokenRefresh(configId, result.tokenStatus);\n      }\n      \n      // Notify listeners\n      this.notifyStatusListeners(configId, result.connectionStatus);\n      \n    } catch (error: any) {\n      console.error(`‚ùå Health check failed for config ${configId}:`, error);\n      \n      // Increment retry count\n      const currentRetries = this.retryCounts.get(configId) || 0;\n      this.retryCounts.set(configId, currentRetries + 1);\n      \n      // Attempt recovery if within retry limits\n      if (currentRetries < this.options.maxRetries) {\n        await this.attemptRecovery(configId, error);\n      } else {\n        console.warn(`‚ö†Ô∏è Max retries exceeded for config ${configId}. Stopping automatic recovery.`);\n        this.notifyStatusListeners(configId, {\n          state: 'error',\n          message: `Connection failed after ${this.options.maxRetries} attempts. Manual intervention required.`,\n          lastChecked: new Date().toISOString(),\n          error: {\n            code: 'MAX_RETRIES_EXCEEDED',\n            message: error.message,\n            retryable: false\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if token needs refresh and refresh if necessary\n   */\n  private async checkTokenRefresh(configId: string, tokenStatus: any): Promise<void> {\n    if (!tokenStatus.expiresAt) return;\n    \n    const expiryTime = new Date(tokenStatus.expiresAt).getTime();\n    const currentTime = Date.now();\n    const timeUntilExpiry = expiryTime - currentTime;\n    const thresholdMs = this.options.tokenRefreshThreshold * 60 * 1000;\n    \n    if (timeUntilExpiry <= thresholdMs && timeUntilExpiry > 0) {\n      console.log(`üîÑ Token expiring soon for config ${configId}. Attempting refresh...`);\n      \n      try {\n        await this.dispatch(refreshTokens(configId)).unwrap();\n        console.log(`‚úÖ Token refreshed successfully for config ${configId}`);\n      } catch (error: any) {\n        console.error(`‚ùå Token refresh failed for config ${configId}:`, error);\n        \n        // If token refresh fails, mark as expired\n        this.notifyStatusListeners(configId, {\n          state: 'expired',\n          message: 'Token refresh failed. Re-authentication required.',\n          lastChecked: new Date().toISOString(),\n          error: {\n            code: 'TOKEN_REFRESH_FAILED',\n            message: error.message,\n            retryable: false\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Attempt to recover from connection errors\n   */\n  private async attemptRecovery(configId: string, error: any): Promise<void> {\n    const retryCount = this.retryCounts.get(configId) || 0;\n    const delay = Math.min(\n      this.options.baseRetryDelay * Math.pow(2, retryCount),\n      this.options.maxRetryDelay\n    );\n    \n    console.log(`üîÑ Scheduling recovery attempt ${retryCount + 1} for config ${configId} in ${delay}ms`);\n    \n    // Notify listeners about retry attempt\n    this.notifyStatusListeners(configId, {\n      state: 'connecting',\n      message: `Connection failed. Retrying in ${Math.round(delay / 1000)} seconds... (Attempt ${retryCount + 1}/${this.options.maxRetries})`,\n      lastChecked: new Date().toISOString(),\n      error: {\n        code: 'CONNECTION_RETRY',\n        message: error.message,\n        retryable: true\n      }\n    });\n    \n    // Schedule retry\n    const retryTimeout = setTimeout(() => {\n      this.performHealthCheck(configId);\n      this.retryTimeouts.delete(configId);\n    }, delay);\n    \n    this.retryTimeouts.set(configId, retryTimeout);\n  }\n\n  /**\n   * Notify all status listeners for a configuration\n   */\n  private notifyStatusListeners(configId: string, status: ConnectionStatus): void {\n    const configListeners = this.listeners.get(configId);\n    if (configListeners) {\n      configListeners.forEach(listener => {\n        try {\n          listener(status);\n        } catch (error) {\n          console.error('Error in status listener:', error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get current retry count for a configuration\n   */\n  getRetryCount(configId: string): number {\n    return this.retryCounts.get(configId) || 0;\n  }\n\n  /**\n   * Reset retry count for a configuration\n   */\n  resetRetryCount(configId: string): void {\n    this.retryCounts.set(configId, 0);\n  }\n\n  /**\n   * Check if a configuration is being monitored\n   */\n  isMonitoring(configId: string): boolean {\n    return this.intervals.has(configId);\n  }\n\n  /**\n   * Get monitoring statistics\n   */\n  getStats(): {\n    monitoredConfigs: number;\n    totalRetries: number;\n    activeRetries: number;\n  } {\n    const totalRetries = Array.from(this.retryCounts.values()).reduce((sum, count) => sum + count, 0);\n    const activeRetries = this.retryTimeouts.size;\n    \n    return {\n      monitoredConfigs: this.intervals.size,\n      totalRetries,\n      activeRetries\n    };\n  }\n\n  /**\n   * Clean up all monitoring\n   */\n  destroy(): void {\n    console.log('üßπ Cleaning up connection manager');\n    \n    // Stop all monitoring\n    Array.from(this.intervals.keys()).forEach(configId => {\n      this.stopMonitoring(configId);\n    });\n    \n    // Clear all listeners\n    this.listeners.clear();\n  }\n}\n\n// Singleton instance for global use\nlet globalConnectionManager: ConnectionManager | null = null;\n\nexport const getConnectionManager = (dispatch: AppDispatch): ConnectionManager => {\n  if (!globalConnectionManager) {\n    globalConnectionManager = new ConnectionManager(dispatch);\n  }\n  return globalConnectionManager;\n};\n\nexport const destroyConnectionManager = (): void => {\n  if (globalConnectionManager) {\n    globalConnectionManager.destroy();\n    globalConnectionManager = null;\n  }\n};"